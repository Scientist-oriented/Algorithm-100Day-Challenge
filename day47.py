# Brainf**k 인터프리터
'''
- 자료구조/알고리즘
    : stack
- 풀이법
    1. 일단 괄호 쌍을 짝지어야 한다.
        : 명령어을 index로 돌면서 여는 괄호가 나오면 stack에 index 넣는다.
        : dict를 하나 만들어서 여는 괄호의 위치와 닫는 괄호의 위치를 저장한다.
    2. 명령어를 돌면서 시뮬레이션 실행하고
    3. cntFH 50,000,000번 이상 실행해본다.
'''
# 오아시스 재결합
'''
- 자료구조/알고리즘
    : stack
- 풀이법
    1. stack에 사람들을 넣고
    2. stack[-1] 부터 탐색하는데 만난 사람의 maxHeight 추적하면서 탐색
    3. maxHeight보다 같거나 크면 + 1, 아니면 - 1
    4. stack.pop()보다 크면 탐색 중단.
'''
# 초콜릿 자르기
'''
- 자료구조/알고리즘
    : DP
- 풀이법
    1. f(i, j) = i * j 초콜릿을 쪼개기 위한 최소 횟수
    2. f(1, i) = 1 for i in range(1, N + 1)
    3. f(i, j) = 2 * f(i - 1, j) + (i - 1)
'''
# 가운데를 말해요.
'''
- 자료구조/알고리즘
    : Heap
- 풀이법
    1. 최대힙, 최소힙 1개씩 선언하고 뒤 힙의 길이가 동일해지도록 push한다.
        : 숫자를 넣을 때 양쪽 heap에서 pop하고 비교해서 적절한 곳에 넣어야 한다.
    2. 홀수번째 숫자는 양쪽 heap에서 pop되는 수랑 비교해서 중간값을 정한다.
    3. 짝수번째 숫자는 양쪽 heap에서 pop되는 수랑 비교해서 작은 값을 중간값으로 정한다.
'''

# 크로스 워드 만들기
'''
- 자료구조/알고리즘
    : Array
- 풀이법
    1. 이중반복문으로 교차점을 찾는다.
    2. 이중반복문 + 분기문으로 결과물을 출력한다.
        : 크로스 되지 않는 줄은 second[행]과 .을 출력하고
        : 크로스 되는 줄은 first[열]을 출력한다.
'''

# 사전
'''
- 자료구조/알고리즘
    : DP
- 풀이법
    1. 첫 자리를 a라고 하면 나머지 자리는 (n + m - 1)C(n - 1)이 된다.
    2. 이런식으로 범위를 좁혀가면서 a, z를 하나하나 구하면 된다.
    3. 다만 이 과정에서 조합 계산을 여러번 하기 때문에 미리 DP로 구현해 놓는다.
'''
# 인구 이동
'''
- 자료구조/알고리즘
    : dfs
- 풀이법
    1. 모든 칸을 완전 탐색해서 연합이 발생하는지 여부를 판단한다.
    2. 연합이 생기면 dfs로 연합을 찾는다.
    3. 연합 사이의 인구를 조건에 맞게 조정하고 visited 처리 한다.
    4.  1로 돌아가 dfs가 더 이상 일어나지 않을 때까지 반복한다.
'''
# 로봇 청소기
'''
- 자료구조/알고리즘
    : 구현
- 풀이법
    1. 변수에 현재 좌표, 바라보는 방향을 저장해서 추적한다.
    2. while True 반복문으로 주어진 작동방식대로 반복하도록 한다.
    3. 작동을 멈추는 조건에서 break한다.
    4. 청소하면 board에 표시하고 ans += 1한다.
    5. 그 동안 청소한 칸을 출력한다.
'''
# 토너먼트
'''
- 자료구조/알고리즘
    : 구현
- 풀이법
    1. f(i)가 i라운드에서 번호라면 f(i + 1) = (f(i) - 1) // 2 + 1
    2. 두 사람의 번호를 라운드 별로 추적한다.
    3. 두 사람이 인접한 번호라면 해당 라운드를 출력한다.
        : 단 부전승이 발생하는 경우 예외처리를 한다.
'''
# 아기 상어
'''
- 자료구조/알고리즘
    : 이차원 배열, 정렬, 완전탐색, bfs
- 풀이법
    1. 완전탐색을 통해서 현재 상어 크기에서 먹을 수 있는 물고기 배열을 만든다.
    2. 현재 물고기의 위치 기준으로 가장 가까운 물고기 순으로 정렬한다.
        : bfs로 거리를 따진다.
    3. 물고기를 먹으러 가고 그 좌표에서 남은 물고기들의 배열을 다시 정렬한다.
    4. 중간에 상어가 커지면 다시 완전탐색해서 먹을 수 있는 물고기를 다시 추린다.
'''
# 드래곤 커브
'''
- 자료구조/알고리즘
- 풀이법
'''

# 토끼의 이동
'''
- 자료구조/알고리즘
    : DP
- 풀이법
    1. 대각선을 기준으로 이차원 배열을 선언한다.
        : 이 배열은 몇번째 대각선이냐에 따라 내부 배열의 길이가 다르다.
    2. 규칙에 맞게 미리 구한다.
    3. 좌표를 통해 몇번째 대각선의 몇번째 수인지 구한다.
    4. 토끼의 움직임을 추적하면서 대각선 배열에서 값을 구해서 더한다.
'''

# 다리 만들기
'''
- 자료구조/알고리즘
    : dfs
- 풀이법
    1. dfs로 섬의 좌표를 전부 찾아서 저장한다.
    2. 각 섬의 모든 좌표를 다른 섬의 좌표의 잇는 다리의 길이를 구한다.
        : bfs 실시한다.
    3. 2의 최솟값을 출력한다.
'''
# 욕심쟁이 판다
'''
- 자료구조/알고리즘
    : bfs
- 풀이법
    1. 숲의 모든 좌표에 대해서 bfs를 실시하면서 판다의 이동 거리를 측정한다.
    2. 이동 거리 중에서 최댓값을 출력한다.
'''
# 가로 세로 퍼즐
'''
- 자료구조/알고리즘
    : 브루트포스
- 풀이법
    1. 조합으로 3개를 뽑아서 가로 3줄로 배열하는 모든 경우에 대해서
    2. 나머지 3개를 세로 3줄로 배열하는 모든 경우와 비교한다.
'''
# 수열 정렬
'''
- 자료구조/알고리즘
    : Array
- 풀이법
    1. enumerate를 이용해서 A배열의 index와 value를 연결한다.
    2. sort를 할 때, value를 기준으로 정렬하고 index는 사전순으로 정렬되도록 key를 준다.
'''
# 