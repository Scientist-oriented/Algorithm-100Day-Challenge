# 설탕 배달
'''
1. f(i) = i 킬로그램을 배달할 때 가장 적게 드는 봉지
2. f(n)
3. f(3) = 1, f(5) = 1 (나머지는 -1로 세팅)
4. if f(i) ≠ -1일 때
        f(i + 3) = f(i) + 1
        f(i + 5) = f(i) + 1
'''
# 1, 2, 3 더하기
'''
1. f(i) = i를 1, 2, 3의 합으로 나타내는 방법의 수
2. f(n)
3. f(1) = 1
    f(2) = 2
    f(3) = 4
4. f(i) = f(i - 3) + f(i - 2) + f(i - 1)
'''
# 피보나치 함수
'''
1. f(i, 0) = fibonacci(i)를 호출했을 때 0이 출력되는 횟수
    f(i, 1) = fibonacci(i)를 호출했을 때 1이 출력되는 횟수
2. f(N, 0), f(N, 1)
3. f(0, 0) = 1, f(0, 1) = 0
    f(1, 0) = 0,  f(1, 1) = 1
4. f(i, 0) = f(i - 2, 0) + f(i - 1, 0)
    f(i, 1) = f(i - 2, 1) + f(i - 1, 1)
'''
# 계단 오르기
'''
1. f(i, True) : i번째 계단이 마지막 계단일 때 i-1번째 계단을 밟고 얻는 최대 점수
   f(i, False): i번째 계단이 마지막 계단일 때 i-1번째 계단을 밟지 않고 얻는 최대 점수
2. max(f(n, True), f(n, False))
2. f(1, True) = (계단1의 점수)
    f(1, False) = (계단1의 점수)
    f(2, True) = (계단1의 점수) + (계단2의 점수)
    f(2, False) = (계단2의 점수)
3. f(i, True) = f(i - 1, False) + (계단i의 점수)
     f(i, False) =  f(i - 2, True) + (계단i의 점수)
'''
# 이친수
'''
1. 정의
    f(i, 0) : i자리 이친수 중에 끝자리가 0인 수
    f(i, 1) : i자리 이친수 중에 끝자리가 1인 수 
2. 구하는 답
    f(n, 0) + f(n, 1)
3. 초기값
    f(1, 0) = 0
    f(1, 1) = 1
4. 점화식
    f(i, 0) = f(i - 1, 0) + f(i - 1, 1)
    f(i, 1) = f(i - 1, 0)
'''

# 연속합
'''
1. 정의
    f(i) : n개의 정수 중에서 i번째 정수까지의 최대 연속합
2. 구하는 답
    f(n)
3. 초기값
    f(1) = arr[1]
4. 점화식
    f(i) = max(arr[i], f(i - 1) + arr[i])
'''
# 가장 긴 증가하는 부분 수열
'''
1. 정의
    f(i) : 수열의 i번째 수까지 가장 긴 증가하는 부분 수열의 길이
2. 구하는 답
    f(n)
3. 초기값
    f(i) = 1 for i in range(n)
4. 점화식
    for j in range(i):
        if A[j] < A[i]:
            f(i) = max(f(i), f(j) + 1)
'''
# 2xn 타일링 2
'''
1. 정의
    f(i) : 2 * i 직사각형을 채우는 방법의 수
2. 구하는 답
    f(n)
3. 초기값
    f(1) = 1
    f(2) = 3
4. 점화식
    f(i) = f(i - 2) * 2 + f(i - 1)
'''
# 파도반 수열
'''
1. 정의
    f(i) : i번째 정삼각형의 변의 길이
2. 구하는 답
    f(n)
3. 초기값
    f(1) = 1
    f(2) = 1
    f(3) = 1
    f(4) = 2
    f(5) = 2
4. 점화식
    f(i) = f(i - 1) + f(i - 5)
'''
# 퇴사
'''
1. 정의
    f(i) : i일에 주어지는 일을 마지막으로 했을 때 최대 수익
2. 구하는 답
    max(f(i))
3. 초기값
    f(i) = P(i) if i + T(i) =< n + 1
4. 점화식
    for j in range(i):
        if j + T(j) <= i: # i일에 주어지는 일과 같이할 수 있음
            f(i) = max(f(i), f(j) + P(i))
'''