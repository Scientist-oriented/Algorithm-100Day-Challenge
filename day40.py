# 카드 구매하기

'''
1. 정의
    f(i) = i가의 카드를 구입할 때 지불하는 금액의 최댓값
2. 구하는 답
    f(n)
3. 초깃값
    f(1) = P(1)
4. 점화식
    f(i) = max(
        P(i),
        f(1) + f(i - 1),
        f(2) + f(i - 2),
        ...
        f(j) + f(i - j)
    )
'''

# 다리 놓기
'''
1. 정의
    f(i, j) = 서쪽에 i개, 동쪽에 j개의 사이트가 있을 때 지울 수 있는 다리의 경우의 수
2. 구하는 답
    f(N, M)
3. 초기값
    f(1, 0) = 1
    f(1, 1) = 1
4. 점화식
    f(i, j) = f(i - 1, j - 1) + f(i - 1, j)
'''

# 오르막 수

'''
1. 정의
    f(i, j) = 길이가 i이고 끝자리가 j인 오르막 수의 갯수
2. 구하는 답
    sum(f(N, 0) + f(N, 1) + ... + f(N, 9))
3. 초기값
    f(1, 0) = f(1, 1) = f(1, 2) = ... = f(1, 9) = 1
4. 점화식
    f(i, j) = f(i - 1, 0) + f(i - 1, 1) + ... + f(i - 1, j)
'''

# 01 타일
'''
1. 정의
    f(i) = 길이가 i인 2진 수열의 갯수
2. 구하는 답
    f(N)
3. 초기값
    f(1) = 1
    f(2) = 2
4. 점화식
    f(i) = f(i - 2) + f(i - 1)
'''
# 가장 긴 감소하는 부분 수열
'''
1. 정의
    f(i) = i번째 수로 끝나는 가장 긴 감소하는 부분 수열
2. 구하는 답
    f(N)
3. 초기값
    f(1) = f(2) = ... = f(N) = 1
4. 점화식
    for j in range(1, i):
        if A[j] > A[i]:
            f(i) = max(f(i), f(j) + 1)
'''
# 가장 긴 바이토닉 부분 수열
'''
1. 정의
    f1(i) = i번째 수로 끝나는 가장 긴 증가하는 부분 수열
    f2(i) = i번째 수로 시작하는 가장 긴 감소하는 부분 수열
2. 구하는 답
    max(f1(i) + f2(i) - 1)
3. 초기값
    f1(1) = ... = f1(N) = 1
    f2(1) = ...= f2(N) = 1
4. 점화식
    for j in range(1, i):
        if A[j] < A[i]:
            f1(i) = max(f1(i), f1(j) + 1)

    for j in range(N, i, -1):
        if A[j] < A[i]:
            f2(i) = max(f2(i), f2(j) + 1)
'''
# 타일 채우기
'''
1. 정의
    f(i) = 3×i 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수
2. 구하는 답
    f(N)
3. 초기값
    f(1) = 0
    f(2) = 3
    f(3) = 0
    f(4) = 8
4. 점화식
    if i == 홀수:
        f(i) = 0
    else:
        f(i) = f(i - 2) * 3
        f(i) += (f(4) + f(6) + ... + f(i - 4)) * 2
'''
# 합분해
'''
1. 정의
    f(i, j) = 정수 j개를 더해서 합이 i가 되는 경우의 수
2. 구하는 답
    f(N, K)
3. 초기값
    i =  0 ~ N일 때
        f(i, 1) = 1
    j = 1 ~ K일 때
        f(0, j) = 1
4. 점화식
    f(i, j) = sum(f(0, j - 1) + f(1, j - 1) + ... + f(i, j - 1)))
'''
# 암호코드
'''
1. 정의
    f(i) = 암호를 앞에서부터 i번째 인덱스까지 읽었을 때 경우의 수
2. 구하는 답
    f(len(A) - 1)
3. 초기값
    f(0) = 1 if int(A[0]) != 0 else 0
    f(1) = 0
    if int(A[1]) != 0:
        f(1) += 1
    if 10 <= int(A[0:2]) <= 26:
        f(1) += 1
4. 점화식
    f(i) = 0
    if int(A[i]) != 0:
        f(i) += f(i - 1)
    if 10 <= int(A[0:2]) <= 26:
        f(i) += f(i - 2)
'''
# 이동하기
'''
1. 정의
    f(i, j) : (i, j)까지 왔을 때 가져올 수 있는 사탕 개수의 최댓값
2. 구하는 답
    f(N, M)
3. 초기값
    f(1, 1) = (1, 1)에 놓여져있는 사탕의 갯수
4. 점화식
    f(i, j) = max(
        ((i, j)의 사탕) + f(i - 1, j),
        ((i, j)의 사탕) + f(i, j - 1),
        ((i, j)의 사탕) + f(i - 1, j - 1)
    )
'''