# 수 묶기
'''
- 자료구조/알고리즘
    : 그리디
- 풀이법
    1. 절댓값이 큰 것끼리 묶어서 곱한다.
    2. 음수는 음수끼리 양수는 양수끼리 곱한다.
    3. 따라서 음수, 양수 구분해서 곱한다.
    4. 홀수인 경우 절댓값이 가장 낮은 것은 그냥 더한다.
- 주의할 점
    : 1은 곱하지 않고 그냥 더하는게 좋다.
'''
# 키 순서
'''
- 자료구조/알고리즘
    : 완전탐색 (dfs)
- 풀이법
    1. 자신의 키를 알 수 있는 학생 node의 특징은
        : 자신의 방문할 수 있는 노드 + 자신이 방문할 수 있는 노드
        : = (자신을 제외한 모든 노드)이다.
    2. 모든 node에서 dfs를 돌면서 visiting과 visited를 만들어서 체크하면 된다.
- 구글링
    : 플로이드 와샬 알고리즘이라고 한다.
'''
# 순열 장난
'''
- 자료구조/알고리즘
    : 백트래킹
- 풀이법
    1. 문자열의 길이로 순열의 길이 N을 구하고
    2. visited 배열을 [False] * (N + 1) 만들어서 dfs를 수행한다.
    3. index 순서로 문자열을 탐색하면서 1자리 수일 때, 2자리 수일 때 각각 재귀로 dfs를 실시한다.
    4. 결과의 순열의 길이가 N이면 리턴한다.
'''
# 행운의 바퀴
'''
- 자료구조/알고리즘
    : 큐
- 풀이법
    1. 일단 큐에 N만큼의 ?를 넣고 시작한다.
    2. 1바퀴 회전 = popleft -> append
    3. 돌린 이후 popleft했을 때 ?이면 알파벳으로 바꾸고
    4. 다른 알파벳이 나오거나 이미 있는 알파벳이 나오면 !를 출력한다.
'''

# Brainf**k 인터프리터
'''
- 자료구조/알고리즘
- 풀이법
'''

# 오아시스 재결합
'''
- 자료구조/알고리즘
    : stack
- 풀이법

'''

# 고기잡이
'''
- 자료구조/알고리즘
    : 완전 탐색
- 풀이법
    1. 모든 좌표를 완전 탐색하면 시간초과가 난다.
    2. 물고기의 좌표가 상대적으로 적으므로 물고기의 좌표마다 완전탐색을 한다.
        : 물고기의 좌표 뿐 아니라 물고기의 교차점도 탐색해야 한다.
    3. I를 활용해서 만들 수 있는 모든 직사각형 사이즈에 대해서도 완전탐색해야 한다.
    4. 즉 (물고기의 좌표 + 물고기 2마리 교차점의 좌표) * (모든 직사각형 케이스)에 대해 완전탐색한다.
'''

# 구슬 탈출 2
'''
- 자료구조/알고리즘
    : bfs
- 풀이법
    1. 큐를 활용해서 R의 경로를 bfs한다.
        : 각 기울이기 4가지 동작에 대해서
    2. 큐에 B의 좌표도 기록하여 파란구슬이 구멍에 빠지는 경로는 탐색하지 않는다.
        : 겹치는 경우에는 굴리기 전 좌표를 보고 R, B가 겹치지 않게 좋정한다.
    3. pop 했는데 cost가 10이상이면 -1
    4. ✅ visited는 4차원 리스트로 만들어서 R의 r, c좌표 + B의 r, c좌표까지 저장한다.
'''
# 좋은 구간
'''
- 자료구조/알고리즘
    : Array
- 풀이법
    1. 주어진 집합을 배열에 담아 정렬한다.
    2. 
        start = 집합의 수 중에 n보다 작은 수 중에 가장 큰 수
        end = 집합의 수 중에 n보다 큰 수 중에서 가장 작은 수
    3. start + 1 ~ end - 1 사이의 범위에서 n을 포함하는 범위의 수를 출력한다.
'''
# 숫자
'''
- 자료구조/알고리즘
    : Set
- 풀이법
    1. A와 B 사이에 모든 수에 대해서 SK(N)연산을 연속적으로 실시한다.
    2. Set을 선언해서 연산의 결과를 저장한다.
    3. Set에 이미 있는 것이 연산의 결과로 나오면 Set 안에 최솟값을 결과에 더한다.
'''
# 리모컨
'''
- 자료구조/알고리즘
    : 완전탐색
- 풀이법
    1. 현재 채널 (100)에서 +/- 버튼으로만 채널을 돌리는데 필요한 횟수를 구한다.
    2. 목표하는 채널에서 +1, -1씩 하면서 멀쩡한 버튼으로 만들 수 있는 가장 채널에 가까운 값을 구한다.
        : 그리고 자릿수 + (그 수에서 +/-버튼이 필요한 갯수)를 구한다.
    3. 1과 2번의 결과를 비교해서 최솟값을 출력한다.
'''
# 등수 구하기
'''
- 자료구조/알고리즘
    : 완전탐색
- 풀이법
    1. 공동등수가 있을 경우 (N + 1) - (더 낮은 점수의 갯수)가 등수가 된다.
    2. N개를 돌면서 더 낮은 점수의 갯수를 센다.
    3. 공동등수를 출력한다.
    4. 단 N + 1 > P이고 꼴찌와 동점이거나 작은 경우는 예외처리한다.
'''
# KMP는 왜 KMP일까?
'''
- 자료구조/알고리즘
    : String
- 풀이법
    1. split('-')으로 분리한 다음에
    2. 각 원소의 첫 글자만 모아서 출력한다.
'''
# 보물
'''
- 자료구조/알고리즘
    : Array, 정렬
- 풀이법
    1. A배열은 오름차순으로, B배열은 내림차순으로 정렬한다.
    2. S함수를 수행한 값을 출력한다.
'''
# 비슷한 단어
'''
- 자료구조/알고리즘
    : 브루트 포스
- 풀이법
    1. 같은 구성인지 알아보는 법
        : String을 list로 바꾸고 정렬해서 같은지 본다.
    2. 하나만 다른 단어인지 알아보는 법
        : String을 list로 바꾸고
            : 길이가 같으면 서로 다른 원소가 1개인지 (filter로 구현)
            : 길이가 다르면 길이의 차이가 1이고 다른 원소들은 모두 같은지
'''
# 귀농
'''
- 자료구조/알고리즘
    : 완전탐색
- 풀이법
    1. N * N 땅에서 땅이 만나는 꼭지점은 (N - 1) ** 2
    2. 각 꼭지점을 기준으로 만들 수 있는 직사각형 쌍을 완전탐색한다.
        : 좌상단 / 우하단 먼저 탐색하고
        : 크로스해서 우상단 / 좌하단 탐색한다.
'''
# 2차원 배열의 합
'''
- 자료구조/알고리즘
    : DP
- 풀이법
    1. 2차원 리스트를 저장하고
    2. 미리 1 ~ N, 1 ~ M까지의 합을 구해서 다른 이차원 리스트에 저장한다.
    3. sumBoard[x][y] - sumBoard[i][y] - sumBoard[x][j] + sumBoard[i][j]를 출력한다.
'''
# 음계
'''
- 자료구조/알고리즘
    : 배열
- 풀이법
    1. 배열의 원소를 [i], [i + 1]을 순차적으로 비교한다.
    2. 처음 2개를 비교하고 ascending과 descending을 결정하고
    3. 다음에 상반되는 것이 나오면 break하고 mixed
    4. 끝까지 유지되면 해당 하는 값을 출력한다.
'''
# 퇴사
'''
- 자료구조/알고리즘
    : DP
- 풀이법
    1. 정의 : dp[i] = i일부터 N일까지 얻을 수 있는 최대 수익
    2. 구하는 답: dp[1]
    2. 초기값: dp[N] = P[i] if T[i] == 1 else 0
    3. 점화식
        if i + T[i] > n:
            dp[i] = dp[i + 1]
        else:
            dp[i] = max(dp[i + 1], P[i] + dp[i + T[i]])
'''
# 연구소
'''
- 자료구조/알고리즘
    : dfs
- 풀이법
    1. 벽 3개를 세우는 모든 경우를 완전탐색한다. (combination)
    2. 벽을 세운 연구소를 완전탐색하면서 2를 만나면 dfs를 실시해서
        바이러스가 퍼진 구역을 계산한다.
    3. 위의 연산을 바탕으로 안전 영역의 최댓값을 구한다.
'''