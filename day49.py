# 사다리 조작
'''
# 자료구조/알고리즘
    : dfs, 브루트포스
# 풀이방법
    1. 이차원 리스트에 연결을 저장한다.
    2. i선에서 출발한 선이 i선에 도착했는지 확인하는 함수를 구현한다.
    3. dfs를 통해서 모든 세로선에 놓아보면서 최솟값을 갱신한다.
'''

# 환승
'''
# 자료구조/알고리즘
    : bfs
# 풀이방법
    1. 하이퍼 튜브가 연결한 역을 바탕으로 인접 배열을 만드는데
        : 하이퍼튜브는 별도의 역으로 간주한다.
    2. bfs를 실시하는데 하이퍼튜브를 거치는 경우는 이동횟수를 0으로 계산한다.
'''

# 윷놀이
'''
# 자료구조/알고리즘
    : Array
# 풀이방법
    1. 입력을 배열로 처리한다.
    2. 배열의 sum으로 어떤 패인지 결정한다.
'''
# 주사위 윷놀이
'''
# 자료구조/알고리즘
    : dfs
# 풀이방법
    1. 말판의 점수들을 배열로 저장하는데 10, 20, 30에 도착해서 꺾이는 부분은 따로 저장
    2. 모든 경로를 dfs로 진행한다.
        : 각 말의 위치를 배열로 저장하고 각 배열이 현재 주사위 눈금에 움직이는 경우를 완전 탐색
        : 현재 위치가 10, 20, 30인 경우 다른 배열로 옮겨서 진행
    3. 최댓값을 출력한다.
'''

# 빙산
'''
# 자료구조 / 알고리즘
    : dfs
# 풀이방법
    - 빙산의 갯수를 셀 때: dfs를 이용해서 연결된 부분을 1개로 처리해서 갯수 세기
    - 빙산이 녹는 것을 처리: 완전탐색을 이용해서 빙산을 모두 만나고 주변의 0 갯수에 따라 녹는 것 처리
        : 주의! 처음에 표시한 배열에 하면 다음 빙산이 녹을 때 영향을 줄 수도 있으므로 주의!
'''
# 비숍
'''
# 자료구조/알고리즘
    : dfs, 백트래킹
# 풀이방법
    1. 놓을 수 있는 좌표를 완전탐색한다.
    2. n-queen 처럼 놓을 수 있는지 없는지 따져가면서 완전 불가능한 곳은 백트래킹한다.
'''
# 원판 돌리기
'''
# 자료구조/알고리즘
    : dfs
# 풀이방법
    1. 행에는 같은 원판에 있는 수를 저장 / 열은 각 원판을 의미하는 이차원 배열을 만든다.
    2. 원판을 회전 시키는 것 = 해당 행의 배열의 index를 조정하는 것으로 구현한다.
    3. 인접하면서 수가 같은 것을 찾을 때는 dfs를 이용해서 인접한 곳에 수가 같으면 그 곳에서 다시 dfs를 재귀하는 식으로 구현
'''
# 선발 명단
'''
# 자료구조/알고리즘
    : 백트래킹
# 풀이방법
    1. dfs로 모든 선수를 모든 포지션에 배치해보는 완전탐색을 실시한다.
    2. 백트래킹을 통해서 더 이상 선수를 배치할 수 없는 경우를 처리한다.
'''
# 바이러스
'''
# 자료구조/알고리즘
    : dfs
# 풀이방법
    1. 주어진 컴퓨터 쌍을 인접행렬로 구현한다.
    2. 1번 컴퓨터에서 dfs를 돌면서 연결된 컴퓨터의 갯수를 구한다.
'''
# 차이를 최대로
'''
# 자료구조/알고리즘
    : 브루탈 포스
# 풀이방법
    1. 순열로 모든 배열 A의 케이스를 구한다.
    2. 주어진 식을 연산하면서 최댓값을 구한다.
'''
# 낚시왕
'''
# 자료구조/알고리즘
    : 구현
# 풀이방법
    1. 상어를 이차원 배열에 저장하고 1초 마다 방향과 속도에 맞추어 좌표를 업데이트한다.
        : 이동할 때 그 좌표에 이미 상어가 있다면 크기를 비교해서 저장
    2. 1초 마다 낚시꾼의 위치를 옮겨가면서 상어가 이동한 다음에 상어를 잡는다.
    3. 총 합을 출력한다.
'''
# 소수의 곱
'''
# 자료구조/알고리즘
    : heap
# 풀이방법
    1. 모든 소수를 일단 heap에 넣는다.
    2. heap에서 pop한 수에 모든 소수를 곱해서 heap에 넣는다.
    3. heap의 pop을 한다.
    4. 2 ~ 3을 N번 반복한다.
'''
# 알약
'''
# 자료구조/알고리즘
    : dp
# 풀이방법
    1. W, H의 갯수를 각각 x, y좌표로 가지는 이차원 리스트를 만든다.
    2. (i, 0)는 모두 1가지이고
    3. (i, j)는 i == j일 경우 (i, j - 1)이고 아니면 (i - 1, j) + (i, j - 1)이다.
'''
# 그리고 하나가 남았다.
'''
# 자료구조/알고리즘
    : queue
# 풀이방법
    1. 돌을 queue에 저장한다.
        : m이 제일 앞으로 오도록
    2. popleft해서 치우고 append(popleft())으로 시계방향으로 회전하는 것을 구현한다.
    3. 큐에 1개가 남을 때까지 2를 반복한다.
'''
# 컴백홈
'''
# 자료구조/알고리즘
    : dfs
# 풀이방법
    1. 재귀함수를 통해 dfs를 실시한다.
    2. 다음 칸으로 visited 처리하고 dfs를 재귀함수로 호출한 다음에는 
        visited에서 지워서 다른 경로에서도 접근할 수 있도록 한다!
'''

# 톱니 바퀴
'''
# 자료구조/알고리즘
    : queue
# 풀이방법
    1. 각 톱니바퀴를 deque로 구현한다.
    2. 시계방향으로 회전은 appendleft(pop()), 시계방향으로 회전은 append(popleft())
    3. 각 회전에 따라 다른 바퀴의 회전을 처리한다.
    4. 점수를 계산해 출력한다.
'''

# 균형잡힌 세상
'''
# 자료구조/알고리즘
    : stack
# 풀이방법
    1. 열린 괄호가 들어오면 stack에 넣고 닫힌 괄호가 들어오면 stack에서 pop한다.
    2. stack에서 pop한 열린 괄호과 닫힌 괄호와 종류가 다르다면 No
    3. 문자열을 다 읽었을 때 stack에 괄호가 남아있어도 No이다.
'''
# 색종이
'''
# 자료구조/알고리즘
    : 그리디
# 풀이방법
    1. 큰 색종이를 일단 판에 넣는다.
    2. 각 색종이마다 남는 공간을 계산하고 남는 공간에 작은 색종이들을 넣는다.
    3. 모든 색종이가 들어갈 때까지 1, 2를 반복한다.
'''
# 히스토그램
'''
# 자료구조/알고리즘
    : stack
# 풀이방법
    1. 왼쪽 부터 stack에 넣는다.
    2. stack이 내림차순으로 유지할 수 있으면 push 안되면 pop한다.
    3. pop할 때 넓이를 구하고 최댓값이면 갱신한다.
'''
# 문제 이름
'''
# 자료구조/알고리즘
# 풀이방법
'''